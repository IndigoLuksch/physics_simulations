'''PURE elements'''

#---import libraries---
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import sys
from tqdm import tqdm
import random

#---notes---
'''
• simulates pure elemental metals (i.e. T_solidus, T_liquidus are constant)
• all units are SI
• each pixel represents a voxel
• we include surface energy contributions in the Gibbs free energy
'''

#---simulation parameters---
x_dim = 100 #arb
y_dim = 100 #arb
pix_dim = 1e-6 #side length of each pixel
dt = 0.5
simulation_time = 1 * 60
#starting_grains = 500

#---material parameters---
#material = str(input("Choose a material.\n\nOptions: 'Al'"))
material = 'Al'

if material == 'Al':
    #PURE ALUMINIUM
    #phase diagram
    T_melt = 660 + 273
    k_S = 220           #W/(m*K) (thermal conductivity) (assume constant within each phase)
    k_L = 100
    #heat flow
    h_LS = 1            #heat transfer coefficient: L<-->S
    h_Sm = 500          #heat transfer coefficient: S<-->mould
    h_Lm = 3500         #heat transfer coefficient: L<-->mould
    #energy
    dH_LS = 1067000000  #J/(m^3)
    E_srf = 0.3         #surface energy between two grains (assume independent of grain angle) (assume E_srf_LS = 0) (source: [1])
    E_srf = 2 #delete this
    #other
    density = 2700      #kg/(m^3)
    n = 5.979e28 * pix_dim**3  #atoms per pixel (mm^3)
    #casting parameters
    T_initial = 640 +273 #change to 1500°C
    T_mold_preheat = 1000 + 273 # <--- not used
    T_mould = 30 + 273        #(assume constant)

    #q = -k ∆T (W/m^2)
else:
    print("Material choice not recognised. Please retry.\n\n[EXECUTION STOPPED]")
    sys.exit()


#---initial processing of parameters---
k_B = 1.38e-23
dS_LS = dH_LS / T_melt

num_frames = int(round(simulation_time / dt))

grid = np.zeros((x_dim,y_dim)) #states
phase_changes = np.zeros((x_dim,y_dim)) #~d/dt(states)
T_grid = np.ones((x_dim, y_dim)) * T_initial #temp

#---define functions---
#determine if state is L (0) or S (1)
def phase(state):
    if state == 0:
        return 0
    else:
        return int(state/state)


#calculate E_srf at an atomic site
def calc_E_srf(state, x, y, grid):
    new_E_srf = 0
    dx_dy = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for dx, dy in dx_dy:
        nx, ny = x + dx, y + dy
        if 0 <= nx < x_dim and 0 <= ny < y_dim: #if neighbour pixel in grid
            if grid[nx, ny] > 0 and grid[nx, ny] != state: #if different from new state and not L
                new_E_srf += E_srf
    return new_E_srf


#calculate ∆G for state change at one site
def calc_dG(state_1, state_2, x, y, grid, T_grid, dH_LS=dH_LS, dS_LS = dS_LS, E_srf=E_srf):
    #state_1 = old state, state_2 = proposed new state
    #find E_srf contribution (penalty)
    initial_E_srf = calc_E_srf(state_1, x, y, grid)
    new_E_srf = calc_E_srf(state_2, x, y, grid)
    dE_srf = new_E_srf - initial_E_srf

    state_1 = phase(state_1) #must be after E_srf loop
    state_2 = phase(state_2)

    return (dH_LS - T_grid[x,y] * dS_LS) * (state_2 - state_1) * (pix_dim**3) + dE_srf * (pix_dim**2)

#---define loop functions
#state loop
def update(frame):
    global grid, im, num_frames, phase_changes

    phase_changes = np.zeros_like(phase_changes)
    batch_size = int(x_dim * y_dim * 0.5) #<--- PURPOSE OF THIS?
    selected_sites = [[random.randint(0,x_dim-1), random.randint(0,y_dim-1)] for _ in range(batch_size)]

    #loop across selected sites
    for x, y in selected_sites:
        #create list of possible states
        neighbours = []
        dx_dy = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dx, dy in dx_dy:
            nx, ny = x + dx, y + dy
            if 0 <= nx < x_dim and 0 <= ny < y_dim and grid[nx, ny] > 0:
                neighbours.append(grid[nx, ny])
        possible_states = neighbours
        possible_states.append(grid[x,y]) #add current state
        possible_states.append(0) #add L
        possible_states.append(random.randint(1,x_dim*y_dim)) #add new grain
        possible_states = list(set(possible_states)) #remove duplicates
        possible_states = [int(i) for i in possible_states]

        #calc probability of each state
        state_probability = []
        for state in possible_states:
            dG = calc_dG(grid[x,y], state, x, y, grid, T_grid) #apply function

            #if dG >= 0: #simplification for now (so that P ≠ inf)
            #    probability = 0
            #else:
            probability = np.exp( -dG / (k_B * T_grid[x,y] * n)) #Boltzmann distribution

            state_probability.append(probability)
        #print(f"dG = {dG}, possible_states = {possible_states}, state_probability = {state_probability}, T = {T_grid[x,y]}")
        
        #select state
        if np.sum(state_probability) > 0:
            index = random.choices(np.arange(0,len(possible_states),1), state_probability)[0]
            new_state = (possible_states[index]) #int? plt.imshow doesnt like
            #print(f"new_state: {new_state}")
            
            #if state changes
            if new_state != grid[x,y]: 
                phase_change = phase(new_state) - phase(grid[x,y])
                phase_changes[x,y] = phase_change #update phase_changes matrix
                grid[x,y] = new_state #updates state
            #print(f"new_grid_xy: {grid[x,y]}")
    '''update T'''

    #stats
    unique, counts = np.unique(grid, return_counts=True)
    num_crystals_add = len(unique)
    count_dict = dict(zip(unique, counts))
    percent_L_add = 100*count_dict[0]/len(grid)
    num_crystals.append(num_crystals_add)
    percent_L.append(percent_L_add)



    grid = grid.astype(np.float32)
    im = ax.imshow(grid, cmap='hsv', vmin=0)
    im.set_data(grid)
    if im: ims.append(im)
    return [im]

'''
#temperature loop
def update_temperature():
    """Solve heat equation using explicit finite difference"""
    T_new = T_grid.copy()

    for i in range(1, x_dim-1):
        for j in range(1, y_dim-1):
            # 2D heat equation: dT/dt = α * (d²T/dx² + d²T/dy²)
            laplacian = (T_grid[i+1,j] + T_grid[i-1,j] +
                        T_grid[i,j+1] + T_grid[i,j-1] -
                        4*T_grid[i,j]) / (dx**2)

            # Account for latent heat release during solidification
    #NO NO NO change it
    T_new = T_new + phase_changes * latent_heat * density * 0.001**3

    # Maintain boundary conditions (mold walls)
    T_new[0, :] = T_mold
    T_new[-1, :] = T_mold
    T_new[:, 0] = T_mold
    T_new[:, -1] = T_mold


    phase_changes = np.zeros((x_dim,y_dim))

    return T_new
'''


#---animation---
#progress bar
pbar = tqdm(total=num_frames, desc="Simulating...")

ims = []

def update_progress(current_frame, total_frames):
    pbar.n = current_frame + 1
    pbar.refresh() # Refresh the display

#prepare
fig, ax = plt.subplots()
im = ax.imshow(grid, cmap='hsv', vmin=0)
num_crystals = []
percent_L = []

#animate and save
ani = FuncAnimation(fig, update, frames=num_frames, blit=True, interval=20)
ani.save('grain_growth.gif', writer='pillow', fps=30, progress_callback=update_progress)

print(f"Len ims = {len(ims)}\nnumber same as frame 0 = {ims.count(ims[0])}")

#stats
plt.plot(num_crystals)
plt.plot(percent_L)
plt.show()


#---data sources---
#[1] https://www.researchgate.net/publication/270216500_Chapter_82_-_Influence_of_Grain_Boundary_Structure_on_Dislocation_Nucleation_in_FCC_Metals
#[2] https://webbook.nist.gov/cgi/cbook.cgi?ID=C7429905&Mask=2
